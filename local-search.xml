<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2022-OS-Comp-Schedule记录</title>
    <link href="/2022/07/27/2022-OS-Comp-Schedule%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/07/27/2022-OS-Comp-Schedule%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-OS-Training-Comp-Daily-Schedule"><a href="#2022-OS-Training-Comp-Daily-Schedule" class="headerlink" title="2022-OS-Training-Comp-Daily-Schedule"></a>2022-OS-Training-Comp-Daily-Schedule</h1><p>此文档为个人参加<a href="https://github.com/LearningOS/rust-based-os-comp2022/blob/main/scheduling.md">2022年开源操作系统训练营</a>的工作记录  </p><p>因对于操作系统&#x2F;基础软件的兴趣而来, 希望能够在本次活动中和大家一起努力, 争取有所收获</p><p>活动目标: 探索把现代系统语言Rust和灵活开放的系统结构RISC-V带入到操作系统的架构与设计的创新中来，思考未来的操作系统应该是什么样。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>07&#x2F;07开始学习, 每周四至下周三为一个循环, 每周三完成周报 &#x2F; 每天晚上完成当日总结</p><p><strong>第一阶段 (7月1日～7月31日)</strong>  </p><table><thead><tr><th></th><th>周四</th><th>周五</th><th>周六</th><th>周天</th><th>周一</th><th>周二</th><th>周三</th><th>周报</th></tr></thead><tbody><tr><td>07&#x2F;07 ~ 07&#x2F;13</td><td><a href="#Day1">Day1</a></td><td><a href="#Day2">Day2</a></td><td><a href="#Day3">Day3</a></td><td><a href="#Day4">Day4</a></td><td><a href="#Day5">Day5</a></td><td><a href="#Day6">Day6</a></td><td><a href="#Day7">Day7</a></td><td><a href="#Week1">第 1 周</a></td></tr><tr><td>07&#x2F;14 ~ 07&#x2F;20</td><td><a href="#Day8">Day8</a></td><td><a href="#Day9">Day9</a></td><td><a href="#Day10">Day10</a></td><td><a href="#Day11">Day11</a></td><td><a href="#Day12">Day12</a></td><td><a href="#Day13">Day13</a></td><td><a href="#Day14">Day14</a></td><td><a href="#Week2">第 2 周</a></td></tr><tr><td>07&#x2F;21 ~ 07&#x2F;27</td><td><a href="#Day15">Day15</a></td><td><a href="#Day16">Day16</a></td><td><a href="#Day17-18">Day17</a></td><td><a href="#Day17-18">Day18</a></td><td><a href="#Day19">Day19</a></td><td><a href="#Day20">Day20</a></td><td><a href="#Day21">Day21</a></td><td><a href="#Week3">第 3 周</a></td></tr></tbody></table><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>今天投入的全部时间都在做 rustlings , 目前进度 50&#x2F;84 , 明天争取搞定 rustlings<br>在完成 rustlings 的过程中, 发现对于 ?操作符 &#x2F; 枚举类型 &#x2F; 错误处理的部分有点遗忘, 有几个题有卡壳的情况<br>明天先快速过一遍 <a href="https://course.rs/basic/compound-type/enum.html">Rust圣经</a> 然后再继续做</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>今天进度: rustlings 64&#x2F;84 , 发现rustlings后面的内容很多不熟悉 (模板 &#x2F; 共享指针 等)<br>还是和昨天一样, 配合着rust圣经一边看一边做题, 最后20道加油</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p><strong>各方向进展</strong><br>Rust</p><ul><li>学习 [关联类型 &#x2F; 宏 &#x2F; 线程] 等部分</li><li>完成 rustlings 84&#x2F;84</li></ul><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><p>配置实验环境, 了解github classroom, 了解实验开发流程, 今日提交通过lab0-0 ， lab0-1</p><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><p>工作太忙，今天暂时没搞，o(╥﹏╥)o</p><h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><p>学习指导书第三章及之前的部分，完成实验一 o(<em>￣︶￣</em>)o， 总结见<a href="https://github.com/LearningOS/lab1-os3-zhaiqiming/blob/main/reports/lab1.md">实验报告1</a></p><h2 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h2><p>今天学习lab2指导书, 完成了 sys_get_task_info &amp; sys_get_time , 主要是在内核中通过Page_table的虚实地址转换,查询系统调用传入地址的真实物理地址, 然后写入相关信息的过程</p><h2 id="Week1"><a href="#Week1" class="headerlink" title="Week1"></a>Week1</h2><p><strong>第 1 周 总结 👨🏼‍🍳</strong><br>本周主要完成了以下内容:<br><strong>Rust:</strong></p><ul><li>学习Rust圣经, 完成rustling(84&#x2F;84)</li></ul><p><strong>自学risc-v系统结构:</strong>  </p><ul><li>复习CS61C部分内容, 之前做得CS61C实验: <a href="https://github.com/zhaiqiming/CS61C">repo</a></li></ul><p><strong>基于Rust语言进行操作系统内核实验</strong>:  </p><ul><li>学习 Open-Source-OS-Training-Camp-2022 文档 , 完成lab0-0, lab0-1, lab1, lab2(除实验报告), lab3 正在开发中…  </li><li>提出PR两个, 一个<a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2022S/pull/14">文档语法问题</a> , 一个 <a href="https://github.com/LearningOS/rust-based-os-comp2022/pull/77">os4-ref的bug</a></li></ul><p><strong>经验总结🐝:</strong></p><ol><li>Rust不同于C++, 遇到不懂的Rust概念时, 可以结合操作系统或者编译的知识去理解, 最好不要借鉴C++ </li><li>我写的Rust代码大概率首次是不会通过编译的😈, 可以先使用 cargo build –release 检查编译问题, 这样比make run速度会快很多</li><li>代码需要高内聚, 这一点在lab2做得不好(在task模块做了很多mm模块的操作), 之后一定严格要求, 尽量在模块内部实现并以接口的方式提供给调用方</li></ol><p><strong>下周目标🐯:</strong><br><strong>Rust:</strong></p><ul><li>(32 Rust Quizes) -&gt; (exercisms.io 快速练习)</li></ul><p><strong>自学risc-v系统结构:</strong></p><ul><li>自学PPT for RISC-V特权指令级架构  </li><li>自学RISC-V手册：一本开源指令集的指南 重点是第10章</li></ul><p><strong>基于Rust语言进行操作系统内核实验</strong>:  </p><ul><li>完成lab2, 3 ,4 ,5全部实验(代码 &amp; 报告)</li></ul><h2 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h2><p>学习lab3的代码</p><h2 id="Day9"><a href="#Day9" class="headerlink" title="Day9"></a>Day9</h2><p>在lab3-os5中完成了向前兼容, 通过了usertests的全部内容</p><h2 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h2><p>完成lab3-os5的全部代码, 通过所有测试(感觉stride测试样例的误差比较大, 最好把测试用例的时长都加大一点,这样就将不同进程的误差比降到了2以下), 同样还没写report😭, 最后一起写吧</p><h2 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h2><p>学习lab4-os6的代码, 主要涉及文件系统, lab4之后的代码make run无法运行, 只能每次make test, 效率略微受到一点影响, 准备提一个issue,询问下助教老师</p><h2 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h2><p>完成lab4-os6, 实现了link&#x2F;unlink&#x2F;fstat, 为文件系统增加多个新功能, 然后在OS完成接入;<br>实现过程中修复bug两个: [重复fs.lock &amp; link时忘记写disk_inode]</p><h2 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h2><p>主要是阅读lab5的指导书, 这部分之前没做过, 估计会比较慢, 争取本周六24点之前完成lab5</p><h2 id="Day14"><a href="#Day14" class="headerlink" title="Day14"></a>Day14</h2><p>暂无进度更新</p><h2 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h2><p><strong>第 2 周 总结 👨🏼‍🍳</strong><br>本周的核心是推lab的进度, 主要完成了以下内容:  </p><p>lab3: 实现Spawn系统调用 &#x2F; 实现基于stride的优先级调度, 实验报告待完成<br>lab4: 实现硬链接相关系统调用(link &#x2F; unlink &#x2F; fstat), 实验报告待完成</p><p>经验总结🐝:  </p><ol><li><strong>关注核心问题, 而不是其他:</strong> 从lab4开始, os*-ref 目录下 make run 已经无法正常运行, 起初还想通过一些手段来fix这个问题. 调试了一天发现没啥进展, 在群里问了过了的其他同学, 直接make test就可以, 所以后面就没看这个问题了; 问题持续跟进, <a href="https://github.com/LearningOS/rust-based-os-comp2022/issues/84">🔗issue</a> </li><li><strong>敏捷迭代:</strong> 当添加的一块代码能进行测试时, 先编译测试, 然后再开发其他. 一次开发太多功能不容易测试, 不容易发现bug. 在 lab4 中, 一把梭完了三个系统调用, 首轮测试时样例一个没过😭, 一点点二分错误位置太痛苦了(尤其是重新make test还很慢233).</li></ol><p><strong>下周目标🐯:</strong><br><strong>Rust:</strong></p><ul><li>[可选] (32 Rust Quizes) -&gt; (exercisms.io 快速练习)</li></ul><p><strong>自学risc-v系统结构:</strong></p><ul><li>[可选] 自学PPT for RISC-V特权指令级架构  </li><li>[必须] 自学RISC-V手册：一本开源指令集的指南 第10章 review</li></ul><p><strong>基于Rust语言进行操作系统内核实验</strong>:  </p><ul><li>[必须] 完成lab3, lab4 实验报告, 完成lab5实验代码 &amp; 报告</li></ul><h2 id="Day15"><a href="#Day15" class="headerlink" title="Day15"></a>Day15</h2><p>暂无进度</p><h2 id="Day16"><a href="#Day16" class="headerlink" title="Day16"></a>Day16</h2><p>基本看完了第八章的内容， 感觉代码变动很大， 优先关注实验涉及到的代码， 看了下锁、信号量、条件变量的基本实现和使用</p><h2 id="Day17-18"><a href="#Day17-18" class="headerlink" title="Day17-18"></a>Day17-18</h2><p>探索如何完成第八章练习，学习死锁相关知识（预防，避免，检测），这块在做的时候有些误区<strong>（因为OS基础不扎实）</strong>，整理一下完成本章练习的心路历程  </p><ol><li>起初，看到练习描述，感觉和银行家算法很相似，又看了rcore指导书看到了死锁避免的算法，感觉用这套流程去实现应该比较正确</li><li>实现的过程中总觉得不对劲， 因为如果是套用银行家算法的话，每个线程能够运行完成需要的资源数组 Max 是没法维护的</li><li>这时候还没意识到是算法选择不对（要选择死锁检测算法，而不是死锁预防算法），还是感觉只是算法不适用， 所以又搜索其他办法，在搜索过程中发现死锁检测和死锁预防的不同， 开始重新看练习描述， 看死锁检测的典型算法</li><li>修改算法实现， 仅通过维护need alloc available，每次deadlock-check的时候只要判断是否每个线程都能开始运行就可以了</li><li>通过全部test，完成全部练习，但是还是对死锁检测的运行原理没太搞懂，留个🔗<a href="https://jackming2271.github.io/2022/07/26/rcore%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A-%E5%85%A8Ch1-8/#%E5%8A%9F%E8%83%BD%E6%80%BB%E7%BB%93-5">已更新</a> ，整理下原理， 之后填充上</li></ol><h2 id="Day19"><a href="#Day19" class="headerlink" title="Day19"></a>Day19</h2><p>开始写lab3、lab4、lab5实验报告</p><h2 id="Day20"><a href="#Day20" class="headerlink" title="Day20"></a>Day20</h2><p>完成Lab3实验报告</p><h2 id="Day21"><a href="#Day21" class="headerlink" title="Day21"></a>Day21</h2><p>完成Lab4 &#x2F; lab5实验报告!</p><h2 id="Week3"><a href="#Week3" class="headerlink" title="Week3"></a>Week3</h2><p><strong>第 3 周 总结 👨🏼‍🍳</strong><br>本周主要完成了以下内容:  </p><ol><li>完成Lab5练习, 实现内核中的死锁检测</li><li>完成Ch3~Ch8全部实验报告</li><li>至此基本完成了 2022-OS-Comp一阶段的全部内容,主要包括:<ol><li><p>在学习实践过程记录表上登记自己每日&#x2F;周学习记录情况的repo网址</p><ul><li>即本文所完成的工作</li></ul></li><li><p>在第一阶段学习issues上的提问和回答问题情况, 的Pull Request提交情况（代码改进、文档改进、文档错误等）</p><ul><li>第一阶段OS学习项目: <a href="https://github.com/LearningOS/rust-based-os-comp2022/pull/77">代码改进PR一个</a> , <a href="https://github.com/LearningOS/rust-based-os-comp2022/issues/84">BUG一个</a></li><li>rCore Tutorial v3的详细实验指导内容: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2022S/pull/14">描述错误一个</a></li></ul></li><li><p>Rustling + OS-Lab(1~5) <a href="https://github.com/orgs/LearningOS/repositories?q=zhaiqiming&type=all&language=&sort=">[Code]</a> <a href="https://jackming2271.github.io/2022/07/26/rcore%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A-%E5%85%A8Ch1-8/">[Report]</a></p></li><li><p>个人收获总结 (待完成)</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>rcore</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>工作记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rcore实验报告(全Lab1~5)</title>
    <link href="/2022/07/26/rcore%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A-%E5%85%A8Ch1-8/"/>
    <url>/2022/07/26/rcore%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A-%E5%85%A8Ch1-8/</url>
    
    <content type="html"><![CDATA[<p>本报告为个人在参与 <strong><a href="https://github.com/LearningOS/rust-based-os-comp2022/blob/main/scheduling.md">2022年开源操作系统训练营</a></strong> 期间完成, 主要包括 6 个实验报告(对应 <a href="https://learningos.github.io/rust-based-os-comp2022/index.html">指导文档</a> 中ch3~8), 内容涉及了操作系统中的 <strong>特权级切换&#x2F;进程调度&#x2F;虚拟内存管理&#x2F;多线程分析等</strong> 重点知识.</p><h1 id="Lab1-Ch3"><a href="#Lab1-Ch3" class="headerlink" title="Lab1-Ch3"></a>Lab1-Ch3</h1><h2 id="功能总结"><a href="#功能总结" class="headerlink" title="功能总结"></a>功能总结</h2><p><strong>实现了sys_task_info系统调用,可以获取当前进程的 运行状态&#x2F;运行时长&#x2F;每种系统调用的使用次数</strong></p><ul><li>运行状态: 由于只能查询当前任务, 所以任务状态只能为 Running</li><li>运行时长: 在TaskControlBlock中记录开始运行的时间戳, 查询时使用 (当前时间 - 开始时间) 获取运行时长</li><li>系统调用的使用次数: 在中断转发时,转发前一刻将系统调用使用次数+1</li></ul><h2 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h2><ol><li>正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容 (运行 Rust 三个 bad 测例 (ch2b_bad_*.rs) ， 注意在编译时至少需要指定 LOG&#x3D;ERROR 才能观察到内核的报错信息) ， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。</li></ol><p><strong>在低特权级使用更高特权级的指令 &#x2F; 访问非法地址等都会触发异常,出core</strong><br>[ERROR] [kernel] PageFault in application, bad addr &#x3D; 0x0, bad instruction &#x3D; 0x80400408, core dumped.<br>[ERROR] [kernel] IllegalInstruction in application, core dumped.<br>[ERROR] [kernel] IllegalInstruction in application, core dumped.  </p><ol start="2"><li>深入理解 trap.S 中两个函数 __alltraps 和 __restore 的作用，并回答如下问题:</li></ol><ul><li><p>L40：刚进入 __restore 时，a0 代表了什么值。请指出 __restore 的两种使用情景。<br>a0 寄存器放置函数返回值, a0中的地址是 trap_handler 的返回值, 指向任务内核栈上的trap_context的地址<br>两种使用场景: 完成中断处理后返回用户态继续执行 &#x2F; 首次被调度为Running时进入用户态</p></li><li><p>L46-L51：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ld</span> t0, <span class="hljs-number">32</span>*<span class="hljs-number">8</span>(sp)<br><span class="hljs-attribute">ld</span> t1, <span class="hljs-number">33</span>*<span class="hljs-number">8</span>(sp)<br><span class="hljs-attribute">ld</span> t2, <span class="hljs-number">2</span>*<span class="hljs-number">8</span>(sp)<br><span class="hljs-attribute">csrw</span> sstatus, t0 // 记录中断发生前的许多信息如特权级等<br><span class="hljs-attribute">csrw</span> sepc, t1 // 系统调用返回用户态时从何处开始执行 or 异常代码发生的位置<br><span class="hljs-attribute">csrw</span> sscratch, t2 // 保存内核栈位置<br></code></pre></td></tr></table></figure></li><li><p>L53-L59：为何跳过了 x2 和 x4？<br>x2: x2即为sp寄存器, 其实已经保存到sscratch了<br>x4: 使用不到,不用保存</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">ld x1, <span class="hljs-number">1</span>*<span class="hljs-number">8</span>(<span class="hljs-built_in">sp</span>)<br>ld x3, <span class="hljs-number">3</span>*<span class="hljs-number">8</span>(<span class="hljs-built_in">sp</span>)<br><span class="hljs-meta">.set</span> n, <span class="hljs-number">5</span><br><span class="hljs-meta">.rept</span> <span class="hljs-number">27</span><br>   LOAD_GP %n<br>   <span class="hljs-meta">.set</span> n, n+<span class="hljs-number">1</span><br><span class="hljs-meta">.endr</span><br></code></pre></td></tr></table></figure></li><li><p>L63：该指令( csrrw sp, sscratch, sp )之后，sp 和 sscratch 中的值分别有什么意义？<br>sp 和 sscratch 分别指向 内核栈&#x2F;用户栈 其中的一个和另一个, 执行之后他们的指向发生交换, 此处sp指向用户栈, sscratch指向进程内核栈</p></li><li><p>__restore：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？<br>sret指令;指令执行后:CPU 会将当前的特权级按照 sstatus 的 SPP 字段设置为 U 或者 S ；CPU 会跳转到 sepc 寄存器指向的那条指令，然后继续执行。</p></li><li><p>L13：该指令( csrrw sp, sscratch, sp )之后，sp 和 sscratch 中的值分别有什么意义？<br>sp 和 sscratch 分别指向 内核栈&#x2F;用户栈 其中的一个和另一个, 执行之后他们的指向发生交换, 此处sscratch指向用户栈, sp指向进程内核栈</p></li><li><p>从 U 态进入 S 态是哪一条指令发生的？<br>ecall</p></li></ul><h2 id="对本次实验设计及难度-x2F-工作量的看法，以及有哪些需要改进的地方"><a href="#对本次实验设计及难度-x2F-工作量的看法，以及有哪些需要改进的地方" class="headerlink" title="对本次实验设计及难度&#x2F;工作量的看法，以及有哪些需要改进的地方"></a>对本次实验设计及难度&#x2F;工作量的看法，以及有哪些需要改进的地方</h2><p>难度适中,对于起步正好合适</p><h1 id="Lab2-Ch4"><a href="#Lab2-Ch4" class="headerlink" title="Lab2-Ch4"></a>Lab2-Ch4</h1><h2 id="功能总结-1"><a href="#功能总结-1" class="headerlink" title="功能总结"></a>功能总结</h2><p>实现了 mmap 和 munmap 系统调用, 提供了在用户态动态申请物理内存的接口  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/// 申请长度为 len 字节的物理内存（不要求实际物理内存位置，可以随便找一块），将其映射到 start 开始的虚存，内存页属性为 port</span><br>fn sys<span class="hljs-constructor">_mmap(<span class="hljs-params">start</span>: <span class="hljs-params">usize</span>, <span class="hljs-params">len</span>: <span class="hljs-params">usize</span>, <span class="hljs-params">port</span>: <span class="hljs-params">usize</span>)</span> -&gt; isize<br><span class="hljs-comment">/// 取消到 [start, start + len) 虚存的映射</span><br>fn sys<span class="hljs-constructor">_munmap(<span class="hljs-params">start</span>: <span class="hljs-params">usize</span>, <span class="hljs-params">len</span>: <span class="hljs-params">usize</span>)</span> -&gt; isize<br></code></pre></td></tr></table></figure><p>mmap实现方法: 通过memory_space的insert_framed_area方法, 每次mmap请求都尝试插入一个area<br>munmap实现方法: 通过遍历当前memory_space下所有area维护的映射, 如果虚拟页面落在在本次要拆除映射的区间, 则进行拆除操作</p><h2 id="问答总结"><a href="#问答总结" class="headerlink" title="问答总结"></a>问答总结</h2><ol><li><p>请列举 SV39 页表页表项的组成，描述其中的标志位有何作用?  </p> <img src="/2022/07/26/rcore%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A-%E5%85%A8Ch1-8/sv39-pte.png" class title="sv39模式页表项"><ul><li>V 位决定了该页表项的其余部分是否有效（V &#x3D; 1 时有效）。若 V &#x3D; 0，则任何遍历到此页表项的虚址转换操作都会导致页错误。</li><li>R、W 和 X 位分别表示此页是否可以读取、写入和执行。如果这三个位都是 0，那么这个页表项是指向下一级页表的指针，否则它是页表树的一个叶节点。</li><li>U 位表示该页是否是用户页面。若 U &#x3D; 0，则 U 模式不能访问此页面，但 S 模式可以。若 U &#x3D; 1，则 U 模式下能访问这个页面，而 S 模式不能。</li><li>G 位表示这个映射是否对所有虚址空间有效，硬件可以用这个信息来提高地址转换的性能。这一位通常只用于属于操作系统的页面。</li><li>A 位表示自从上次 A 位被清除以来，该页面访问过。</li><li>D 位表示自从上次清除 D 位以来页面是否被弄脏（例如被写入）。</li><li>RSW 域留给操作系统使用，它会被硬件忽略。</li><li>PPN 域包含物理页号，这是物理地址的一部分。若这个页表项是一个叶节点，那么 PPN 是转换后物理地址的一部分。否则 PPN 给出下一节页表的地址。</li></ul></li><li><p>缺页</p></li></ol><blockquote><p>缺页异常是一种正在运行的程序访问当前未由内存管理单元（MMU）映射到虚拟内存的页面时，由计算机硬件引发的异常类型。访问未被映射的页或访问权限不足，都会导致该类异常的发生。处理缺页异常通常是操作系统内核的一部分。当处理缺页异常时，操作系统将尝试使所需页面在物理内存中的位置变得可访问（建立新的映射关系到虚拟内存）。而如果在非法访问内存的情况下，即发现触发Page Fault的虚拟内存地址(Bad Address)不在当前进程 vm_area_struct链表中所定义的允许访问的虚拟内存地址范围内，或访问位置的权限条件不满足时，缺页异常处理将终止该程序的继续运行。</p></blockquote><ul><li><p>请问哪些异常可能是缺页导致的？<br>  当系统运行发生异常时，可即时地通过解析csr scause寄存器的值，识别如下三种不同的Page Fault</p><p>  Exception Code &#x3D; 12: page fault caused by an instruction fetch<br>  Exception Code &#x3D; 13: page fault caused by a read<br>  Exception Code &#x3D; 15: page fault caused by a write  </p></li><li><p>发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略.<br>  八个控制状态寄存器（CSR）是机器模式(M态)下异常处理的必要部分：</p><ul><li>mtvec（Machine Trap Vector）它保存发生异常时处理器需要跳转到的地址。</li><li>mepc（Machine Exception PC）它指向发生异常的指令。</li><li>mcause（Machine Exception Cause）它指示发生异常的种类。</li><li>mie（Machine Interrupt Enable）它指出处理器目前能处理和必须忽略的中断。</li><li>mip（Machine Interrupt Pending）它列出目前正准备处理的中断。</li><li>mtval（Machine Trap Value）它保存了陷入（trap）的附加信息：地址exception中出错的地址、发生非法指令exception的指令本身，对于其他异常，它的值为 0。</li><li>mscratch（Machine Scratch）它暂时存放一个字大小的数据。</li><li>mstatus（Machine Status）它保存全局中断使能，以及许多其他的状态</li></ul><p>  S 模式有几个异常处理 CSR：sepc、stvec、scause、sscratch、stval 和 sstatus，它们执行与 M 模式 CSR 同的功能。监管者异常返回指令 sret 与 mret 的行为相同，但它作用于 S 模式的异常处理CSR，而不是 M 模式的 CSR。S 模式处理例外的行为已和 M 模式非常相似。如果 hart 接受了异常并且把它委派给了S 模式，则硬件会原子地经历几个类似的状态转换，其中用到了 S 模式而不是 M 模式的CSR:</p><ul><li>发生例外的指令的 PC 被存入 sepc，且 PC 被设置为 stvec。</li><li>scause 根据异常类型设置值，stval 被设置成出错的地址或者其它特定异常的信息字。</li><li>把 sstatus CSR 中的 SIE 置零，屏蔽中断，且 SIE 之前的值被保存在 SPIE 中。</li><li>发生exception时的权限模式被保存在 sstatus 的 SPP 域，然后设置当前模式为 S 模式。</li></ul></li><li><p>缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。这样做有哪些好处？<br>  基于此机制, 程序开始运行时并不需要将全部内容加载到内存, 也就是说在 程序运行的机器的实际物理内存 小于 进程运行所需总内存时, 程序依然能够通过页面的换入换出机制运行起来;</p></li></ul><blockquote><p>其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。</p></blockquote><ul><li><p>处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？<br>  10G &#x2F; 512</p></li><li><p>请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。<br>  不考虑局部性的情况下, 使用lazy策略时, 根据发生缺页异常的类型, 去memory_set的各个段寻找 [缺页的虚拟地址在当前逻辑段 &amp;&amp; 逻辑段权限达到缺页的要求], 如果寻找成功, 则将页面加载到物理内存并映射;</p></li><li><p>缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。此时页面失效如何表现在页表项(PTE)上？<br>  V权限位为0<br>双页表与单页表</p></li></ul><ol start="3"><li>为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单&#x2F;双的说法仅为自创的通俗说法，并无这个名词概念，详情见 KPTI )</li></ol><ul><li><p>在单页表情况下，如何更换页表？<br>  切换任务后, 返回用户态时重写sntp</p></li><li><p>单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）<br>  内核对应的地址只允许在内核态访问, PTE 的 U &#x3D; 0</p></li><li><p>单页表有何优势？（回答合理即可）<br>  用户态和内核态切换时不用更换页表</p></li><li><p>双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？<br>  用户态和内核态切换时; 在返回用户态时 or 任务切换时, 因为内核部分都是一样的;</p></li></ul><h2 id="对本次实验设计及难度-x2F-工作量的看法，以及有哪些需要改进的地方-1"><a href="#对本次实验设计及难度-x2F-工作量的看法，以及有哪些需要改进的地方-1" class="headerlink" title="对本次实验设计及难度&#x2F;工作量的看法，以及有哪些需要改进的地方"></a>对本次实验设计及难度&#x2F;工作量的看法，以及有哪些需要改进的地方</h2><pre><code class="hljs">难点在于理解虚拟内存, 实验代码基于现有框架难度不大. 希望能有Lazy策略 和 Swap策略的实现学习 orz</code></pre><h1 id="Lab3-Ch5"><a href="#Lab3-Ch5" class="headerlink" title="Lab3-Ch5"></a>Lab3-Ch5</h1><h2 id="功能总结-2"><a href="#功能总结-2" class="headerlink" title="功能总结"></a>功能总结</h2><p>spwan系统调用<br>新建子进程，使其执行目标程序 (从结果来看是等于Fork + Exec, 但是过程是不同的)<br>实现思路: 整体过程基本与task::new()的过程相同</p><p><a href="https://en.wikipedia.org/wiki/Stride_scheduling"> stride 优先级调度算法 </a>   </p><p>基于优先级的进程调度算法, 每个进程有一个优先级, 优先级越高执行频率越高<br>实现思路: 在TASK_MANAGER中每次选择stride最小的进程, 按照调度算法计算出步长(MAX_STRIDE &#x2F; Priority), 然后进程stride加上这个值; 关于原理可以参看: <a href="https://blog.csdn.net/Anna__1997/article/details/88891432">关于stride schedule很好的一个解释</a></p><h2 id="问答总结-1"><a href="#问答总结-1" class="headerlink" title="问答总结"></a>问答总结</h2><p><strong>stride 算法深入</strong></p><p>stride 算法原理非常简单，但是有一个比较大的问题。例如两个 stride &#x3D; 10 的进程，使用 8bit 无符号整形储存 pass， p1.pass &#x3D; 255, p2.pass &#x3D; 250，在 p2 执行一个时间片后，理论上下一次应该 p1 执行。</p><ul><li>实际情况是轮到 p1 执行吗？为什么？<br>  不是, 250 + 10 &#x3D; 260 , 无符号整数溢出后回转变为 4 (260 % 256) , 4 &lt; 255 , 所以 p2 继续执行</li></ul><p>我们之前要求进程优先级 &gt;&#x3D; 2 其实就是为了解决这个问题。可以证明， 在不考虑溢出的情况下 , 在进程优先级全部 &gt;&#x3D; 2 的情况下，如果严格按照算法执行，那么 PASS_MAX – PASS_MIN &lt;&#x3D; BigStride &#x2F; 2</p><ul><li>为什么？尝试简单说明（不要求严格证明）。<br>  每次增大的都是最小的, 每次增大的步幅小的进程调度的次数多, 每次增大的步幅大的进程调度的次数少  <img src="/2022/07/26/rcore%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A-%E5%85%A8Ch1-8/stride.png" class title="stride调度进程PASS值变化"></li></ul><p>已知以上结论，考虑溢出的情况下，可以为 pass 设计特别的比较器，让 BinaryHeap<Pass> 的 pop 方法能返回真正最小的 Pass。补全下列代码中的 partial_cmp 函数，假设两个 Pass 永远不会相等。<br>TIPS: 使用 8 bits 存储 pass, BigStride &#x3D; 255, 则: (125 &lt; 255) &#x3D;&#x3D; false, (129 &lt; 255) &#x3D;&#x3D; true.</Pass></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> core::cmp::Ordering;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pass</span>(<span class="hljs-type">u64</span>);<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PartialOrd</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Pass</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">partial_cmp</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Ordering&gt; &#123;<br>        <br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">cmp</span>: <span class="hljs-type">i64</span> = (<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> - other.<span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">i64</span>; <br>        <span class="hljs-keyword">if</span> cmp &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(Ordering::Less)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> cmp == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(Ordering::Equal)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(Ordering::Greater)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PartialEq</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Pass</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eq</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对本次实验设计及难度-x2F-工作量的看法，以及有哪些需要改进的地方-2"><a href="#对本次实验设计及难度-x2F-工作量的看法，以及有哪些需要改进的地方-2" class="headerlink" title="对本次实验设计及难度&#x2F;工作量的看法，以及有哪些需要改进的地方"></a>对本次实验设计及难度&#x2F;工作量的看法，以及有哪些需要改进的地方</h2><pre><code class="hljs">可以在练习部分多给出一些相关参考资料</code></pre><h1 id="Lab4-Ch6"><a href="#Lab4-Ch6" class="headerlink" title="Lab4-Ch6"></a>Lab4-Ch6</h1><h2 id="功能总结-3"><a href="#功能总结-3" class="headerlink" title="功能总结"></a>功能总结</h2><p>实现三个系统调用 sys_linkat、sys_unlinkat、sys_stat</p><ul><li>sys_linkat: 为现有的文件创建一个硬连接; 通过在FileSystem中添加一个name不同但是inode相同的目录项实现;</li><li>sys_unlinkat: 取消硬连接; 删除目录项; 如果删除后硬链接数量 &#x3D; 0, 回收文件占用的资源;</li><li>sys_stat: 获取文件的各种信息如硬链接数量等</li></ul><h2 id="问答总结-2"><a href="#问答总结-2" class="headerlink" title="问答总结"></a>问答总结</h2><ol><li>在我们的easy-fs中，root inode起着什么作用？如果root inode中的内容损坏了，会发生什么？<br> root inode是根目录索引的inode, root inode 对应的数据区维护了所有的目录项;<br> 如果损坏目录项会丢失, 导致无法根据name对文件进行操作</li></ol><h2 id="你对本次实验设计及难度-x2F-工作量的看法，以及有哪些需要改进的地方，欢迎畅所欲言"><a href="#你对本次实验设计及难度-x2F-工作量的看法，以及有哪些需要改进的地方，欢迎畅所欲言" class="headerlink" title="你对本次实验设计及难度&#x2F;工作量的看法，以及有哪些需要改进的地方，欢迎畅所欲言"></a>你对本次实验设计及难度&#x2F;工作量的看法，以及有哪些需要改进的地方，欢迎畅所欲言</h2><h1 id="Ch7"><a href="#Ch7" class="headerlink" title="Ch7"></a>Ch7</h1><h2 id="功能总结-4"><a href="#功能总结-4" class="headerlink" title="功能总结"></a>功能总结</h2><p>本章无编程内容</p><h2 id="问答总结-3"><a href="#问答总结-3" class="headerlink" title="问答总结"></a>问答总结</h2><ol><li><p>举出使用 pipe 的一个实际应用的例子<br>netstat -nap | grep 80</p></li><li><p>如果需要在多个进程间互相通信，则需要为每一对进程建立一个管道，非常繁琐，请设计一个更易用的多进程通信机制<br> 消息队列, 共享内存等</p></li></ol><h1 id="Lab5-Ch8"><a href="#Lab5-Ch8" class="headerlink" title="Lab5-Ch8"></a>Lab5-Ch8</h1><h2 id="功能总结-5"><a href="#功能总结-5" class="headerlink" title="功能总结"></a>功能总结</h2><p>实现死锁检测功能. 目前的 mutex 和 semaphore 相关的系统调用不会分析资源的依赖情况，用户程序可能出现死锁。 我们希望在系统中加入死锁检测机制，当发现可能发生死锁时拒绝对应的资源获取请求.<br>注意此处的死锁检测和银行家算法(死锁避免算法)是不同的, 死锁检测是针对当前状态, 判断当前资源分配情况是否能让所有线程都继续运行(而不是每个都运行结束). 所以只基于每个线程对资源的请求(即 锁Lock or 信号量down), 来构造需求矩阵need &#x2F; 维护alloc &#x2F; 维护available , 就能完成判断了</p><h2 id="问答总结-4"><a href="#问答总结-4" class="headerlink" title="问答总结"></a>问答总结</h2><ol><li><p>在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。 </p><ul><li>需要回收的资源有哪些？<br> 回收TaskUserRes相关(提前回收, 不然会释放两次, 因为drop在函数周期结束后才调用, 晚于memory_set.recycle_data_pages调用), 回收fd_table, 回收children </li><li>其他线程的 TaskControlBlock 可能在哪些位置被引用，分别是否需要回收，为什么？<br> 可能在锁或者信号量等的数据结构上, 但是不用回收, 地址空间已回收, 子线程运行时会自动失败</li></ul></li><li><p>对比以下两种 Mutex.unlock 的实现，二者有什么区别？这些区别可能会导致什么问题?<br> 如下第二种实现, 虽然将等待锁的线程重新开始调度, 但是锁并未释放, 会导致死锁</p> <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-number">1</span> impl Mutex <span class="hljs-keyword">for</span> Mutex1 &#123;  <br> <span class="hljs-number">2</span>    fn unlock(&amp;self) &#123;  <br> <span class="hljs-number">3</span>        <span class="hljs-keyword">let</span> mut mutex_inner = self.inner.exclusive<span class="hljs-constructor">_access()</span>;  <br> <span class="hljs-number">4</span>        <span class="hljs-keyword">assert</span>!(mutex_inner.locked);  <br> <span class="hljs-number">5</span>        mutex_inner.locked = <span class="hljs-literal">false</span>;  <br> <span class="hljs-number">6</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-constructor">Some(<span class="hljs-params">waking_task</span>)</span> = mutex_inner.wait_queue.pop<span class="hljs-constructor">_front()</span> &#123;  <br> <span class="hljs-number">7</span>            add<span class="hljs-constructor">_task(<span class="hljs-params">waking_task</span>)</span>;  <br> <span class="hljs-number">8</span>        &#125;  <br> <span class="hljs-number">9</span>    &#125;  <br><span class="hljs-number">10</span> &#125;  <br><span class="hljs-number">11</span>  <br><span class="hljs-number">12</span> impl Mutex <span class="hljs-keyword">for</span> Mutex2 &#123;  <br><span class="hljs-number">13</span>    fn unlock(&amp;self) &#123;  <br><span class="hljs-number">14</span>        <span class="hljs-keyword">let</span> mut mutex_inner = self.inner.exclusive<span class="hljs-constructor">_access()</span>;  <br><span class="hljs-number">15</span>        <span class="hljs-keyword">assert</span>!(mutex_inner.locked);  <br><span class="hljs-number">16</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-constructor">Some(<span class="hljs-params">waking_task</span>)</span> = mutex_inner.wait_queue.pop<span class="hljs-constructor">_front()</span> &#123;  <br><span class="hljs-number">17</span>            add<span class="hljs-constructor">_task(<span class="hljs-params">waking_task</span>)</span>;  <br><span class="hljs-number">18</span>        &#125; <span class="hljs-keyword">else</span> &#123;  <br><span class="hljs-number">19</span>            mutex_inner.locked = <span class="hljs-literal">false</span>;  <br><span class="hljs-number">20</span>        &#125;  <br><span class="hljs-number">21</span>    &#125;  <br><span class="hljs-number">22</span> &#125;  <br></code></pre></td></tr></table></figure></li></ol><h2 id="你对本次实验设计及难度-x2F-工作量的看法，以及有哪些需要改进的地方，欢迎畅所欲言-1"><a href="#你对本次实验设计及难度-x2F-工作量的看法，以及有哪些需要改进的地方，欢迎畅所欲言-1" class="headerlink" title="你对本次实验设计及难度&#x2F;工作量的看法，以及有哪些需要改进的地方，欢迎畅所欲言"></a>你对本次实验设计及难度&#x2F;工作量的看法，以及有哪些需要改进的地方，欢迎畅所欲言</h2><pre><code class="hljs">可以同时讲一下死锁避免和死锁检测, 不然可能会混淆(本人亲历ಥ_ಥ)</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>rcore</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>rcore</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
